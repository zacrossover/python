# Pagerank
## 发展历史

PageRank，又称网页排名、谷歌左侧排名、PR，是Google公司所使用的对其搜索引擎搜索结果中的网页进行排名的一种算法。佩奇排名本质上是一种以网页之间的超链接个数和质量作为主要因素粗略地分析网页的重要性的算法。其基本假设是：更重要的页面往往更多地被其他页面引用（或称其他页面中会更多地加入通向该页面的超链接）。 其将从A页面到B页面的链接解释为“A页面给B页面投票”，并根据投票来源（甚至来源的来源，即链接到A页面的页面）和投票对象的等级来决定被投票页面的等级。该算法以谷歌公司创始人之一的拉里·佩奇（Larry Page）的名字来命名。谷歌搜索引擎用它来分析网页的相关性和重要性，在搜索引擎优化中经常被用来作为评估网页优化的成效因素之一。

目前，佩奇排名算法不再是谷歌公司用来给网页进行排名的唯一算法，但它是最早的，也是最著名的算法。

## 算法介绍
我们先来看下 PageRank 是如何计算的。
一个网页的pagerank是网页的重要程度，可以看成是其他网页对该网页的投票，更重要的网页引用比不重要的网页引用权重更高，计算一个网页的pagerank又要先计算引用他的网页的pagerank，所以该问题是一个递归问题。

我假设一共有 4 个网页 A、B、C、D。它们之间的链接信息的有向图所图示：

![pagerank1](https://github.com/zacrossover/python/assets/15845563/06eada68-13c7-40eb-aa17-897085eaf355)

Pagerank值的公式如下所示：

$$ PR(p_i) = \sum_{p_j \in M(p_i)} \frac{PR(p_j)}{L(p_j)} $$ 

页面的Pagerank就等于所有入链的分数总和。我们假设每个页面的分数是平均分配给所有出链的，令所有页面的总分数都是1，为各边加权，可以得到下图：

![pagerank2](https://github.com/zacrossover/python/assets/15845563/5f9e4ecf-eb88-43bb-a192-11fadf0e7d67)

根据上述加权有向图可以转成一个矩阵，元素的值代表从一个页面到另一个页面的投票

$$M=
\begin{bmatrix}
0 & 1/2 & 1 & 0 \\
1/3 & 0 & 0 & 1/2 \\
1/3 & 0 & 0 & 1/2 \\
1/3 & 1/2 & 0 & 0 
\end{bmatrix}
$$


之后我们假设四个网页初始的pagerank相同，可以得到下面的向量w_0

$$w_0=
\begin{bmatrix}
1/4 \\
1/4 \\
1/4 \\
1/4
\end{bmatrix}
$$

对初始的pagerank进行第一次迭代，相当于对上面向量根据投票的矩阵进行线性变换，可以得到w_1

$$w_1 = Mw_0 = \left[
 \begin{matrix}
0 & 1/2 & 1 & 0 \\
1/3 & 0 & 0 & 1/2 \\
1/3 & 0 & 0 & 1/2 \\
1/3 & 1/2 & 0 & 0 
  \end{matrix}
  \right] \left[
 \begin{matrix}
1/4 \\
1/4 \\
1/4 \\
1/4
  \end{matrix}
  \right] =  \begin{bmatrix}
3/8 \\
5/24 \\
5/24 \\
5/24
  \end{bmatrix}$$


再对w_1进行投票，得到w_2:

$$w_2 = Mw_1 = \left[
 \begin{matrix}
0 & 1/2 & 1 & 0 \\
1/3 & 0 & 0 & 1/2 \\
1/3 & 0 & 0 & 1/2 \\
1/3 & 1/2 & 0 & 0 
  \end{matrix}
  \right] \left[
 \begin{matrix}
3/8 \\
5/24 \\
5/24 \\
5/24
  \end{matrix}
  \right] =  \begin{bmatrix}
5/16 \\
11/48 \\
11/48 \\
11/48
  \end{bmatrix}$$
  
依此类推，网页的pagerank向量w将最终收敛，这就是最后pagerank的结果。

$$\begin{bmatrix}
0.3333 \\
0.2222 \\
0.2222 \\
0.2222
  \end{bmatrix}$$

上面过程相当于不断的对初始向量w_0做左乘矩阵M的操作，当上一次的结果w_i于w_i+1的差小于一个 $\epsilon$ 时，迭代结束，得到的向量w_i+1即为最终的pagerank值。

但在现实情况中，可能存在某些页面没有向外的链接，那经过迭代之后，这个页面的pagerank将变为1，其他页面都为0；或者某些页面没有访问它的页面，那它的pagerank将是0，这些结果都是没有意义的。为了解决这个问题，该算法引入了随机浏览者（random surfer）的概念，即假设某人在浏览器中随机打开某些页面并点击了某些链接。为了便于理解，这里假设上网者不断点击网页上的链接直到进入一个没有外部链接的网页，此时他会随机浏览其他的网页（可以与之前的网页无关）。为了表达这种概率，引入一个阻尼系数d，表示用户与1-d的概率停止继续点击链接，随机浏览网页，pagerank的公式就变为 

$$ PR(p_i) = \frac{1-d}{N} + d \sum_{p_j \in M(p_i)} \frac{PR(p_j)}{L(p_j)} $$ 



## 时间复杂度分析

根据上面算法分析，该算法的运行过程为不断算 $ n \times n $ 矩阵乘以一个n维向量，单次做矩阵乘法的时间复杂度为n^2，令迭代次数为 $t(\varepsilon)$ ，则时间复杂度为：

$$ O(t(\varepsilon)n^2) $$


## 代码实现

https://www.cnblogs.com/jpcflyer/p/11180263.html
https://mahua.jser.me/
